#!/usr/bin/env -S corepack yarn node

import { writeFile } from 'fs/promises'
import http2 from 'http2'
import { isIP } from 'net'
import { stderr } from 'process'

if (process.argv.length < 5) {
  stderr.write(`ERROR: Missing required arguments.
`)
}

const urlhaus = {
  name: `acid-chicken/little-snitch-rules#urlhaus`,
  descripion: `Built from Malicious URL Blocklist`,
  [`denied-remote-addresses`]: new Set(),
  [`denied-remote-domains`]: new Set(),
}
const phishing = {
  name: `acid-chicken/little-snitch-rules#phishing`,
  descripion: `Built from Malicious URL Blocklist`,
  [`denied-remote-addresses`]: new Set(),
  [`denied-remote-domains`]: new Set(),
}
const pup = {
  name: `acid-chicken/little-snitch-rules#pup`,
  description: `Built from Malicious URL Blocklist`,
  [`denied-remote-addresses`]: new Set(),
  [`denied-remote-domains`]: new Set(),
}
const session = http2.connect(`https://malware-filter.pages.dev`)

/**
 * @arg {String} entry
 * @arg {Set.<String>} resultAddress
 * @arg {Set.<String>} resultDomains
 */
function processEntry(entry, resultAddress, resultDomains) {
  if (!entry || entry[0] === `#`) {
    return
  }

  entry = entry.replace(/^\s+|\s+$/g, ``).replace(/(?<=^[\d.]*\.)0+(?=\d[\d.]*$)/g, ``)

  if (isIP(entry)) {
    resultAddress.add(entry)
  } else {
    resultDomains.add(entry)
  }
}

/**
 * @arg {String} path
 * @arg {Set.<String>} resultAddress
 * @arg {Set.<String>} resultDomains
 */
async function fetch(path, resultAddress, resultDomains) {
  const request = session.request({
    [http2.constants.HTTP2_HEADER_METHOD]: `GET`,
    [http2.constants.HTTP2_HEADER_PATH]: path,
  })
  const [responseHeaders, responseFlags] = await new Promise((resolve) => request.on(`response`, (headers, flags) => resolve([headers, flags])))

  if (responseHeaders[http2.constants.HTTP2_HEADER_STATUS] !== 200) {
    stderr.write(`ERROR: "${path}" ${http2.constants.HTTP2_HEADER_STATUS} = ${responseHeaders[http2.constants.HTTP2_HEADER_STATUS]}
`)
    process.exit(1)
  }

  let remain = ``

  request.setEncoding(`utf8`)

  for await (const responseChunk of request) {
    const [entry, ...rest] = /** @type {String} */ (responseChunk).split(`
`)

    remain += entry

    if (rest.length) {
      processEntry(remain, resultAddress, resultDomains)

      for (const entry of rest.slice(0, -1)) {
        processEntry(entry, resultAddress, resultDomains)
      }

      remain = rest.at(-1)
    }
  }
}

async function writeResult(name, result) {
  await writeFile(name, JSON.stringify(result, (key, value) => value instanceof Set ? Array.from(value) : value, 2))
}

await Promise.all([
  fetch(`/urlhaus-filter-domains.txt`, urlhaus[`denied-remote-addresses`], urlhaus[`denied-remote-domains`]).then(() => writeResult(process.argv[2], urlhaus)),
  fetch(`/phishing-filter-domains.txt`, phishing[`denied-remote-addresses`], phishing[`denied-remote-domains`]).then(() => writeResult(process.argv[3], phishing)),
  /*
  fetch(`/pup-filter-domains.txt`, pup[`denied-remote-addresses`], pup[`denied-remote-domains`]).then(() => writeResult(process.argv[4], pup)),
   */
])

session.close()
